<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Padrino | matt.mc]]></title>
  <link href="http://sh1ps.github.com/blog/categories/padrino/atom.xml" rel="self"/>
  <link href="http://sh1ps.github.com/"/>
  <updated>2012-10-07T18:17:00-04:00</updated>
  <id>http://sh1ps.github.com/</id>
  <author>
    <name><![CDATA[Matthew McClure]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Part 2: Real-Time Voting with PubNub]]></title>
    <link href="http://sh1ps.github.com/blog/2012/10/06/part-2-real-time-voting-with-pubnub/"/>
    <updated>2012-10-06T09:50:00-04:00</updated>
    <id>http://sh1ps.github.com/blog/2012/10/06/part-2-real-time-voting-with-pubnub</id>
    <content type="html"><![CDATA[<p>In <a href="/blog/2012/10/04/real-time-voting-with-pubnub/">part 1</a>, we created a really simple and utterly useless voting application. If you're following along, at this point you should have an application that displays a round of songs that you can vote on and never see them update unless you refresh the page. Now comes the fun part of tying everything together with PubNub.</p>

<p>If you don't already have a PubNub account, you're going to need to go to their site and <a href="http://www.pubnub.com/free-trial">create one</a>. After you've signed up, make note of the Publish and Subscribe keys you see on your Account page, as you'll be using those shortly.</p>

<p>Now that we've got a PubNub account ready, let's start prepping the application for it. First we'll need to add the PubNub gem to our Gemfile. <em>Note: At this point we still need to use an old version of the gem due to a bug causing some problems with Thin, but I'll update here once it's resolved.</em></p>

<pre><code>gem 'pubnub', '~&gt; 0.1'
</code></pre>

<p>The version isn't necessarily required, but I like to include them just in case. If you were curious, the <a href="http://docs.rubygems.org/read/chapter/16#page74">version constraint</a> <code>~&gt;</code> is identical to <code>&gt;= 3.3.0</code> and <code>&lt; 3.4</code>. We can assume they won't change anything that would break our code in versions <code>3.3.1</code> through <code>3.3.9</code>, so we can allow it to update to those versions when we update our bundle.</p>

<p>Once you've added the gem and run <code>bundle install</code>, we can set up the necessary PubNub connections in our app. First let's set up the publishing in the app. We need to instantiate a new PubNub object using at least the publish key from our PubNub account page. I like to do it above all the routes, so we'll place it right above our root route. Make sure you switch out the publish and subscribe placeholders for your own!</p>

<p>``` ruby app.rb
PUBNUB = Pubnub.new(
  'PUBLISH-KEY',
  'SUBSCRIBE-KEY',
  '', # Secret Key (optional)
  '', # Cipher Key (optional)
  false # Use SSL? (optional)
)</p>

<p>get '\' do
…
```</p>

<p>Now we just need to add the actual publish command to the vote route. We want to happen after a song and round have successfully been saved.</p>

<p>``` ruby
…
if @song.save and @round.save
  @songs = Round.current.first.songs
  logger.info "Total votes: #{@round.total_votes}"</p>

<p>  publish = PUBNUB.publish({</p>

<pre><code>'channel' =&gt; 'votr-vote',
'message' =&gt; { 'total_votes' =&gt; @round.total_votes, 'songs' =&gt; @songs },
'callback' =&gt; lambda do |message|
  logger.info message
end
</code></pre>

<p>  })</p>

<p>  render :success => true, :attributes => { 'round' => @round, 'songs' => @songs }
…
<code>``
See how easy that was? Fire up the application using</code>padrino s` and vote on a few songs. If you want to be able to see the messages you're sending, go to your <a href="https://pubnub-prod.appspot.com/console">PubNub console</a>, make sure you connect to the correct channel ("votr-vote" if you used what I did) and then send some more votes. You should see something like this in your console.</p>

<p><img src="http://f.cl.ly/items/2o0w1M0z3m0P3j1M0G3j/Screen%20Shot%202012-10-06%20at%2011.05.29%20AM.png" alt="PubNub Console" /></p>

<p>At this point, we're able to accept votes and publish a message to our PubNub channel with the updated round stats. All that's left is to write a little JavaScript to subscribe to that channel and update the round whenever a new message comes in.</p>

<p>``` javascript views/layouts/application.haml</p>

<div pub-key="PUBLISH-KEY" sub-key="SUBSCRIBE-KEY" ssl="off" origin="pubsub.pubnub.com" id="pubnub"></div>


<p>%script{ :src => "http://cdn.pubnub.com/pubnub-3.1.min.js" }
- unless @round.blank?
 :javascript</p>

<p>   function disableVoting() {</p>

<pre><code> … 
</code></pre>

<p>   }</p>

<p>   function update_votes(message) {</p>

<pre><code> console.log("Message Recieved");
 total_votes = message.total_votes;
 $.each(message.songs, function(index, value) {
   $("#song_" + this.id + " .votes").text(this.votes);
 });
 update_percentages(message);
</code></pre>

<p>   }</p>

<p>   function update_percentages(message) {</p>

<pre><code> total_votes = message.total_votes;
 $.each(message.songs, function(index, value) {
   percentage = this.votes / total_votes;
   $("#song_" + this.id + " .progress .bar").width(percentage * 100 + "%");
 });
</code></pre>

<p>   }</p>

<p>   $(function () {</p>

<pre><code> $('#clock').countdown({until: #{@timer.to_i}, format: 'HMS', compact: true, onExpiry: disableVoting});

 update_votes(#{@msg});

 $('.vote').click(function(event) {
   … 
 });

 // LISTEN FOR MESSAGES
 PUBNUB.subscribe({
   channel    : "votr-vote",
   restore    : false,
   callback   : update_votes,
   disconnect : function() {        // LOST CONNECTION.
     console.log("Disconnected from PubNub.");
   },
   reconnect  : function() {        // CONNECTION RESTORED.
     console.log("Reconnected to PubNub.");
   },
   connect    : function() {        // CONNECTION ESTABLISHED.
     console.log("Connected to PubNub.");
   }
 })
</code></pre>

<p>   });
```
Let's follow what's happening step by step. Right when the page loads, update_votes(#{@msg}) is called. @msg is essentially the same message that gets sent via PubNub, so all we're doing is sending the round as-is to the user right when the page loads. update_votes() then sets each song's vote count and then calls update_percentages(), which is what actually sets the width of the progress bars. update_votes() then gets called every time a new message is received from PubNub.</p>

<p>Since we haven't put any restrictions on the number of times you can vote, open up a few browser windows side by side and start clicking away. You should see all of your open windows updating simultaneously.</p>

<p>So there you have it! You'll notice in the <a href="https://github.com/sh1ps/padrino-pubnub-votr">repository</a> there's an admin directory. This is a cool feature of Padrino that allows you to essentially drop in an admin interface by simply running <code>padrino g admin</code>. The admin interface in the repository has been modified to look like the rest of the application, but otherwise it's largely similar to the generated version. For more info on the Padrino Admin generator see the <a href="http://www.padrinorb.com/guides/padrino-admin">Padrino guides</a>.</p>

<p><img src="http://f.cl.ly/items/3N2H1D3z2R420T1N2y0t/Screen%20Shot%202012-10-07%20at%205.27.52%20PM.png" alt="Votr Admin Interface" /></p>

<p>There you have it! Vote away and enjoy. If you have any questions or suggestions, don't hesitate to drop me a line on Twitter <a href="http://twitter.com/matt_mcclure">@matt_mcclure</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Part 1: Real-Time Voting with PubNub]]></title>
    <link href="http://sh1ps.github.com/blog/2012/10/04/real-time-voting-with-pubnub/"/>
    <updated>2012-10-04T18:58:00-04:00</updated>
    <id>http://sh1ps.github.com/blog/2012/10/04/real-time-voting-with-pubnub</id>
    <content type="html"><![CDATA[<p>Delivering real-time updates to users has never been easier thanks to some <a href="http://socket.io/">open-source</a> <a href="http://faye.jcoglan.com/">projects</a> and <a href="http://www.pusher.com">great</a> <a href="https://www.hydna.com">startups</a> that have popped up. I started using PubNub for <a href="http://tunewolf.co">TuneWolf</a>, and so far I couldn't be happier.</p>

<p>When I first started using PubNub, they didn't have the enormous client-library you see now and the Ruby examples were a little scarce, so I decided to build something fun in order to get acquainted with the service. I'd also been hearing great things about <a href="http://padrinorb.com">Padrino</a>, so I decided to try out the two together.</p>

<p>The result was <a href="http://song-votr.herokuapp.com">Song-Votr</a>, a simple voting application that puts one round of songs up at a time. Users can vote on the songs they like and also see everyone else's votes happening in real-time. Before we look at any code, let's lay out the broad overview of how everything interacts.</p>

<p>Song-Votr serves up the current round of songs. When a user clicks on a song, the client places the vote via an AJAX post request. Song-Votr increments the selected song's vote count along with the total number of votes for the round, then publishes a message to our PubNub channel with the new stats for the round. The user that placed the vote (along with all other connected users) receives that updated round information and the client updates the view.</p>

<p><img src="/images/Diagram.png" alt="image" /></p>

<p>In a nutshell, all clients are only subscribed to PubNub, and the server only publishes messages. This allows Song-Votr to be the gatekeeper of the PubNub channel, making sure that users are only getting votes that were successfully processed.</p>

<h2>Setting Up</h2>

<p>Since we're using Padrino let's go ahead and generate the project. I'm a sucker for Haml and Sass, so we'll use those along with ActiveRecord for our ORM and, of course, jQuery. The -b flag simply runs bundle install after generation.</p>

<pre><code>$ padrino g project votr -e haml -c sass -s jquery -d activerecord -b
</code></pre>

<p>I used ActiveRecord because I come from Rails and I'm familiar with it, but you could always switch that out for whatever adapter you prefer. Assuming you are using AR, the next step is to generate our models. Our model is dead simple, consisting of just two models: a round that has many songs.</p>

<pre><code>$ padrino g model round start_time:datetime end_time:datetime total_votes:integer -a app
$ padrino g model song title:string artist:string votes:integer percentage:float round_id:integer -a app
</code></pre>

<p>This will also generate the necessary migrations. Before you run them, let's go in and add a default value of 0 to total_votes in round and votes in songs. When you're done, those migrations should look similar to what's below.</p>

<p>``` ruby 001_create_rounds.rb
class CreateRounds &lt; ActiveRecord::Migration
  def self.up</p>

<pre><code>create_table :rounds do |t|
  t.datetime :start_time
  t.datetime :end_time
  t.integer :total_votes, :default =&gt; 0
  t.timestamps
end
</code></pre>

<p>  end</p>

<p>  def self.down</p>

<pre><code>drop_table :rounds
</code></pre>

<p>  end
end
```</p>

<p>``` ruby 002_create_songs.rb
class CreateSongs &lt; ActiveRecord::Migration
  def self.up</p>

<pre><code>create_table :songs do |t|
  t.string :title
  t.string :artist
  t.integer :votes, :default =&gt; 0
  t.float :percentage
  t.integer :round_id
  t.timestamps
end
</code></pre>

<p>  end</p>

<p>  def self.down</p>

<pre><code>drop_table :songs
</code></pre>

<p>  end
end
```</p>

<p>Once you're done, make sure you run the migrations with the command <code>padrino rake ar:migrate</code>.</p>

<p>With our database now ready, we need to go into the models and define the relationships. While we're in there, let's go ahead and write a scope to get the current round since that's something we'll definitely need soon.</p>

<p>``` ruby round.rb
class Round &lt; ActiveRecord::Base<br/>
  has_many :songs</p>

<p>  scope :current, lambda {</p>

<pre><code>where("start_time &lt;= ? and end_time &gt; ?", DateTime.now, DateTime.now)  
</code></pre>

<p>  }<br/>
end
```</p>

<p><code>ruby song.rb
class Song &lt; ActiveRecord::Base
  belongs_to :round  
end
</code></p>

<p>A neat feature about Padrino is its drop-in admin interface, but let's not worry about that yet. For now, we'll insert a round and some songs into the database from the console.</p>

<pre><code>$ padrino c
&gt; round = Round.new
&gt; round.start_time = DateTime.now
&gt; round.end_time = DateTime.now + 3.days
&gt; round.save!

&gt; song = round.songs.new
&gt; song.title = "My Heart Will Go On"
&gt; song.artist = "Celine Dion"
&gt; song.save!
</code></pre>

<p>Repeat the song process for a few more songs so you can have things to vote on for the next 3 days. Once you're done, your database should be prepped and ready!</p>

<h2>Front page and layout</h2>

<p>Because there are only two routes, we can get away with just using the base app.rb file as our only controller. Let's go ahead and make our root route and decide what we need to pass to our view. We'll want a timer to show how much time is left in the round, along with the round itself (and associated songs). Notice we're using the current scope we set up in our model. Padrino is based on <a href="http://www.sinatrarb.com/">Sinatra</a>, so if you've ever used Sinatra this syntax should be very familiar.</p>

<p>``` ruby app.rb
get '/' do</p>

<p>  @round = Round.current.first</p>

<p>  unless @round.blank? || @round.end_time.past?</p>

<pre><code>difference = @round.end_time - DateTime.now.to_i
@timer = difference
@songs = @round.songs.order("artist")
@msg = { :songs =&gt; @songs, :round =&gt; @round, :total_votes =&gt; @round.total_votes }.to_json
</code></pre>

<p>  end</p>

<p>  render 'index'
end
```</p>

<p>Now it's time to actually make an interface for people to see. I was planning on using this for a demo, so I took the time to style it up. If you'd like to go ahead and simply copy my <a href="https://github.com/sh1ps/padrino-pubnub-votr/blob/master/app/stylesheets/application.scss">stylesheet</a> from the repository, go ahead and do that now.</p>

<p>Our layout is going to be simple for now. I almost always start my projects with Nicolas Gallagher's <a href="http://necolas.github.com/normalize.css/">Normalize</a>, and Keith Wood's <a href="http://keith-wood.name/countdown.html">jquery.countdown</a> is what's going to make our clock actually count down.</p>

<p>``` haml views/layouts/application.haml
!!! 5
%html
  %head</p>

<pre><code>%title Votr
%meta{ :content =&gt; "", :name =&gt; "description" }
%meta{ :content =&gt; "", :name =&gt; "author" }
%meta{ :content =&gt; "3 days", :name =&gt; "revisit-after" }
%link{ :href =&gt; "http://creativecommons.org/licenses/by/3.0/", :rel =&gt; "license", :title =&gt; "Creative Commons Attribution 3.0 Unported License" }
%script{ :src =&gt; "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" }
= stylesheet_link_tag 'normalize', 'application'
= javascript_include_tag 'application', 'jquery.countdown'
</code></pre>

<p>  %body</p>

<pre><code>= yield

%footer
  %p
    #{link_to("SongVotr", "http://github.com/sh1ps/padrino-pubnub-votr")}. By #{link_to("@matt_mcclure", "http://www.twitter.com/matt_mcclure")}.

- unless @round.blank?
  :javascript
    $(function(){
      $('#clock').countdown({until: #{@timer.to_i}, format: 'HMS', compact: true, onExpiry: disableVoting});
    });
</code></pre>

<p>```</p>

<p>The index view itself is pretty self explanatory. We want to display the clock at the top, followed by a list of the songs in the current round, their current votes, and the percentage of the total vote they've received. As you can see, we went ahead and made each song title a link. We'll be making that /vote route next.</p>

<p>``` ruby views/index.haml
- unless @timer.blank?</p>

<p>  %header</p>

<pre><code>%h1 What do &lt;span class="blue"&gt;you&lt;/span&gt; want to hear next?
%p Click the song titles to vote.
%h1#clock.blue
</code></pre>

<ul>
<li>unless @songs.blank?
%ul.selections

<ul>
<li>@songs.each do |s|
%li[s]
  %h3

<pre><code>= link_to "#{s.artist} - #{s.title}", "/vote?id=#{s.id}", :class =&gt; "vote"
%small (&lt;span class="votes"&gt;#{s.votes}&lt;/span&gt; votes)
</code></pre>

  .progress

<pre><code>.outline
.bar
</code></pre></li>
</ul>
</li>
<li><p>else
%p No songs to vote on!</p></li>
<li><p>else</p>

<p>%header
  %h1 Nothing to currently vote on. Come back later.</p></li>
</ul>


<p>```</p>

<h2>Placing Votes</h2>

<p>The /vote route is where almost all of the real functionality of the app lies. Because we're only allowing for one active round at a time, we can just get the current round. We can cut down on the number of SQL queries by going ahead and eager loading songs along with the round. This can be done via the includes method you see on Round in the second line.</p>

<p>Other than that, all that's happening is incrementing the total votes for the round and the number of votes for the song. We then recalculate that song's percentage (just for archival purposes) and return success or failure based on whether or not the song / round was persisted.</p>

<p>Notice that we're querying the database again for all of the songs. This is because when we plug PubNub in, we need to be publishing <em>all</em> of the songs in order to be able to recalculate all of their percentages and votes on the client side.</p>

<p>``` ruby
post '/vote', :provides => :json do
  @round = Round.includes(:songs).current.first</p>

<p>  unless @round.end_time.past?</p>

<pre><code>@songs = @round.songs.order("artist")
@song = @songs.find(params[:id])
@song.votes = @song.votes + 1
@round.total_votes = @round.total_votes + 1

@song.percentage = @song.votes.to_f / @round.total_votes.to_f

if @song.save and @round.save
  @songs = Round.current.first.songs
  logger.info "Total votes: #{@round.total_votes}"

  render :success =&gt; true, :attributes =&gt; { 'round' =&gt; @round, 'songs' =&gt; @songs }

else
  render :success =&gt; false, :attributes =&gt; {:message =&gt; "Unable to save your vote..."}
end
</code></pre>

<p>  else</p>

<pre><code>render :success =&gt; false, :attributes =&gt; {:message =&gt; "The voting is already over."}
</code></pre>

<p>  end
end
```
Now that the /vote route works, we need to add a little Javascript so the vote is sent via ajax. Change the javascript block in the layout to look something like this:</p>

<p>``` javascript views/layouts/application.haml
:javascript
  // Reload the window whenever the clock gets to zero so we can get the next round.
  function disableVoting() {</p>

<pre><code>alert("This round's over! New round starting...");
window.location.reload();
</code></pre>

<p>  }</p>

<p>  $(function(){</p>

<pre><code>$('#clock').countdown({until: #{@timer.to_i}, format: 'HMS', compact: true, onExpiry: disableVoting});

$('.vote').click(function(event) {
  event.preventDefault();
  var $link = $(this);

  $.ajax({
    type: 'POST',
    url: $link.attr('href'),
    success: function (response) {
      console.log("Vote placed.");
    },
    error: function (response) {
      console.log("Error: vote not placed.");
      alert("Vote could not be placed at this time.");
    }
  });
});
</code></pre>

<p>  });
```</p>

<h2><a href="/blog/2012/10/06/part-2-real-time-voting-with-pubnub/">Making it Live</a></h2>

<p>Now that we have our rounds and we're able to post votes to them, we need to make it so everyone can see everyone's votes as their happening. Because this post is starting to get incredibly lengthy, let's take a breather and tackle the PubNub integration in the <a href="/blog/2012/10/06/part-2-real-time-voting-with-pubnub/">next post</a>.</p>

<h2>If you're interested...</h2>

<p>If this interested you, <a href="http://www.twilio.com">Twilio</a> posted a <a href="http://www.twilio.com/blog/2012/09/building-a-real-time-sms-voting-app-part-1-node-js-couchdb.html">tutorial</a> on building a similar project using their service along with Node.js and CouchDB. Happy hacking!</p>

<p>- Matt</p>
]]></content>
  </entry>
  
</feed>
